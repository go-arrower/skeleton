// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getQueues = `-- name: GetQueues :many
SELECT queue
FROM arrower.gue_jobs
UNION
SELECT queue
FROM arrower.gue_jobs_history
`

func (q *Queries) GetQueues(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getQueues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var queue string
		if err := rows.Scan(&queue); err != nil {
			return nil, err
		}
		items = append(items, queue)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const jobHistoryPayloadSize = `-- name: JobHistoryPayloadSize :one
SELECT COALESCE(pg_size_pretty(SUM(pg_column_size(arrower.gue_jobs_history.args))), '')
FROM arrower.gue_jobs_history
WHERE queue = $1
  AND created_at <= $2
  AND args <> ''
`

type JobHistoryPayloadSizeParams struct {
	Queue     string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) JobHistoryPayloadSize(ctx context.Context, arg JobHistoryPayloadSizeParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, jobHistoryPayloadSize, arg.Queue, arg.CreatedAt)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const jobHistorySize = `-- name: JobHistorySize :one
SELECT COALESCE(pg_size_pretty(SUM(pg_column_size(arrower.gue_jobs_history.*))), '')
FROM arrower.gue_jobs_history
WHERE created_at <= $1
`

func (q *Queries) JobHistorySize(ctx context.Context, createdAt pgtype.Timestamptz) (interface{}, error) {
	row := q.db.QueryRow(ctx, jobHistorySize, createdAt)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const jobTableSize = `-- name: JobTableSize :one
SELECT pg_size_pretty(pg_total_relation_size('arrower.gue_jobs'))         as jobs,
       pg_size_pretty(pg_total_relation_size('arrower.gue_jobs_history')) as history
`

type JobTableSizeRow struct {
	Jobs    string
	History string
}

func (q *Queries) JobTableSize(ctx context.Context) (JobTableSizeRow, error) {
	row := q.db.QueryRow(ctx, jobTableSize)
	var i JobTableSizeRow
	err := row.Scan(&i.Jobs, &i.History)
	return i, err
}

const jobTypes = `-- name: JobTypes :many
SELECT DISTINCT(job_type)
FROM arrower.gue_jobs_history
WHERE queue = $1
`

func (q *Queries) JobTypes(ctx context.Context, queue string) ([]string, error) {
	rows, err := q.db.Query(ctx, jobTypes, queue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var job_type string
		if err := rows.Scan(&job_type); err != nil {
			return nil, err
		}
		items = append(items, job_type)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pendingJobs = `-- name: PendingJobs :many
SELECT bins.t, COUNT(t)
FROM (SELECT date_bin($1, finished_at, TIMESTAMP WITH TIME ZONE'2001-01-01')::TIMESTAMPTZ as t
      FROM arrower.gue_jobs_history
      WHERE finished_at > $2) bins
GROUP BY bins.t
ORDER BY bins.t DESC
LIMIT $3
`

type PendingJobsParams struct {
	DateBin    pgtype.Interval
	FinishedAt pgtype.Timestamptz
	Limit      int32
}

type PendingJobsRow struct {
	T     pgtype.Timestamptz
	Count int64
}

func (q *Queries) PendingJobs(ctx context.Context, arg PendingJobsParams) ([]PendingJobsRow, error) {
	rows, err := q.db.Query(ctx, pendingJobs, arg.DateBin, arg.FinishedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingJobsRow
	for rows.Next() {
		var i PendingJobsRow
		if err := rows.Scan(&i.T, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneHistory = `-- name: PruneHistory :exec
DELETE
FROM arrower.gue_jobs_history
WHERE created_at <= $1
`

func (q *Queries) PruneHistory(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, pruneHistory, createdAt)
	return err
}

const pruneHistoryPayload = `-- name: PruneHistoryPayload :exec
UPDATE arrower.gue_jobs_history
SET args = ''::BYTEA
WHERE queue = $1
  AND created_at <= $2
`

type PruneHistoryPayloadParams struct {
	Queue     string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) PruneHistoryPayload(ctx context.Context, arg PruneHistoryPayloadParams) error {
	_, err := q.db.Exec(ctx, pruneHistoryPayload, arg.Queue, arg.CreatedAt)
	return err
}

type ScheduleJobsParams struct {
	JobID     string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Queue     string
	JobType   string
	Priority  int16
	RunAt     pgtype.Timestamptz
	Args      []byte
}
